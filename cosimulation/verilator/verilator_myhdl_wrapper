#!/usr/bin/env python2.7
# -*- Python -*- See copyright, etc below
######################################################################

import argparse
import os
import re

VERSION = '0.001'
Debug = 0

#======================================================================
# main

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', help='enable debug', action='store_const', const=9)
    parser.add_argument('src', help='Input .h filename, from Verilator output', action='store')
    parser.add_argument('dest', help='Output .cpp filename', action='store')
    Args = parser.parse_args()

    verilator_wrap_gen(src_filename=Args.src, dest_filename=Args.dest)

# TODO perhaps better as part of MyHDL core routines?
# Then would call this function as a MyHDL import, instead of as an executable
def verilator_wrap_gen(src_filename, dest_filename):
    """Given the src_filename which is a Verilator-generated top-level .h file,
    create the dest_filename which is a C++ file containing signal information."""
    model = _VerilatorWrapGen()
    model.read_data(src_filename)
    model.write_converter(dest_filename)

#######################################################################

class _VerilatorWrapGen:
    """Information and reader/writers to support generating Verilator wrapper headers."""
    def __init__(self):
        self.modname = None
        self.signals = []

    @staticmethod
    def storage_size(bits):
        """Return number of bytes needed to store signal of given bit width."""
        if bits <= 8:
            return 1
        if bits <= 16:
            return 2
        if bits <= 32:
            return 4
        if bits <= 64:
            return 8
        return int((bits+63)/64)

    def read_data(self, filename):
        """Read a Verilator-generated filename."""
        with open(filename) as fh:
            for line in fh:
                group = re.search(r'^\s*VL_MODULE*\(\s*([a-zA-Z_0-9]+)\s*', line)
                if (group):
                    self.modname = group.group(1)

                # Verilator makes VL_IN/VL_OUT macros for every I/O that shows the width
                group = re.search(r'^\s*VL_(IN|OUT)[0-9W]*\(\s*(\S+)\s*,\s*(\d+)\s*,\s*(\d+)', line)
                if (group):
                    direction = group.group(1)
                    signame = group.group(2)
                    hi = int(group.group(3))
                    lo = int(group.group(4))
                    bits = hi - lo + 1
                    self.signals.append({'name': signame,
                                         'direction' : direction,
                                         'hi': hi,
                                         'lo': lo,
                                         'bits': bits,
                                         'prev_offset': None })
        fh.close()

    def calculate(self):
        """Calculate sizes."""
        tot_size = 0
        for sig in self.signals:
            sig['prev_offset'] = tot_size
            tot_size += self.storage_size(sig['bits'])
        self.total_storage = tot_size

    def write_converter(self, filename):
        """Write wrapper to given filename."""
        self.calculate()
        with open(filename, "w") as fh:
            fh.write("// Automatically generated by verilator_myhdl_wrapper from %s.h\n"
                     % self.modname)

            fh.write("\n")
            fh.write("#define MODEL %s\n" % self.modname)
            fh.write("\n")
            fh.write("#include <cstddef>\n")
            fh.write("#include <verilated.h>\n")

            fh.write("\n")
            fh.write("#include \"%s.h\"\n" % self.modname)

            fh.write("\n")
            fh.write("struct myhdl_signal {\n")
            fh.write("  const char* name;\n")
            fh.write("  int bits;\n")
            fh.write("  void* datap;\n")
            fh.write("  void* prevp;\n")
            fh.write("  void eol() {\n")
            fh.write("    name=NULL; bits=0; datap=NULL; prevp=NULL;\n")
            fh.write("  }\n")
            fh.write("  void setup_in(const char* name_, int bits_, void* datap_, void* prevp_) {\n")
            fh.write("    name=name_; bits=bits_; datap=datap_; prevp=prevp_;\n")
            fh.write("  }\n")
            fh.write("  void setup_out(const char* name_, int bits_, void* datap_, void* prevp_) {\n")
            fh.write("    name=name_; bits=bits_; datap=datap_; prevp=prevp_;\n")
            fh.write("  }\n")
            fh.write("};\n")

            fh.write("\n")
            fh.write("static myhdl_signal myhdl_inputs[%d];\n" % (len(self.signals)+1))
            fh.write("static myhdl_signal myhdl_outputs[%d];\n" % (len(self.signals)+1))
            fh.write("static vluint8_t myhdl_prev[%d];\n" % (self.total_storage))

            fh.write("\n")
            fh.write("static void myhdl_io_setup(%s* top) {\n" % self.modname)

            i = 0
            for sig in self.signals:
                if sig['direction'] == 'IN':
                    fh.write("  myhdl_inputs[%d].setup_in(\"%s\", %d, &(top->%s), &myhdl_prev[%d]);\n"
                             % (i, sig['name'], sig['bits'],
                                sig['name'], sig['prev_offset']))
                    i += 1
            fh.write("  myhdl_inputs[%d].eol();\n" % i)

            fh.write("\n")
            i = 0
            for sig in self.signals:
                if sig['direction'] == 'OUT':
                    fh.write("  myhdl_outputs[%d].setup_out(\"%s\", %d, &(top->%s), &myhdl_prev[%d]);\n"
                             % (i, sig['name'], sig['bits'],
                                sig['name'], sig['prev_offset']))
                    i += 1
            fh.write("  myhdl_outputs[%d].eol();\n" % i)
            fh.write("};\n")

            fh.write("\n")
            fh.write("//***********************\n")
            fh.write("// Compile into this object\n")
            fh.write("\n")
            fh.write("#include \"myhdl.cpp\"\n")
            fh.write("#include \"verilator_myhdl_main.cpp\"\n")
            fh.close()

#######################################################################

main()

######################################################################
### Local Variables:
### compile-command: "./verilator_myhdl_wrapper test/obj_dir/Vdff.h test/obj_dir/Vdff__myhdl.cpp && cat test/obj_dir/Vdff__myhdl.cpp"
### End:
